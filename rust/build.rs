// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

// Portions adapted from `https://github.com/kuzudb/kuzu/blob/master/tools/rust_api/build.rs` (MIT License).

use std::env;
use std::path::{Path, PathBuf};

fn link_libraries() {
    // Link to system Arrow, `libarrow` is under `/usr/lib/x86_64-linux-gnu/` on Ubuntu
    println!("cargo:rustc-link-search=native=/usr/lib/x86_64-linux-gnu/");
    println!("cargo:rustc-link-lib=dylib=arrow_compute");
    println!("cargo:rustc-link-lib=dylib=arrow_dataset");
    println!("cargo:rustc-link-lib=dylib=arrow_acero");
    println!("cargo:rustc-link-lib=dylib=arrow");

    println!("cargo:rustc-link-lib=graphar");
}

fn build_ffi(bridge_file: &str, out_name: &str, source_file: &str, include_paths: &[PathBuf]) {
    let mut build = cxx_build::bridge(bridge_file);
    build.file(source_file);

    build.includes(include_paths);
    // TODO support MSVC
    build.flag("-std=c++17");
    build.flag("-fdiagnostics-color=always");

    build.compile(out_name);
}

fn build_graphar() -> Vec<PathBuf> {
    let root = Path::new(env!("CARGO_MANIFEST_DIR")).join("..").join("cpp");
    let mut build = cmake::Config::new(&root);

    // 1. Check if `GRAPHAR_BUILD_TYPE` is set. The value must be `Release`, `Debug` or `RelWithDebInfo`
    // 2. If not, fallback to `PROFILE` which is set by `cargo`
    let cmake_build_type =
        env::var("GRAPHAR_BUILD_TYPE").unwrap_or_else(|_| match env::var("PROFILE").as_deref() {
            Ok("release") => "Release".to_string(),
            _ => "Debug".to_string(),
        });

    println!("cargo:rerun-if-env-changed=GRAPHAR_BUILD_TYPE");
    println!("cargo:rerun-if-env-changed=PROFILE");

    build
        .no_build_target(true)
        .define("CMAKE_BUILD_TYPE", cmake_build_type)
        .define("GRAPHAR_BUILD_STATIC", "on");
    let build_dir = build.build();

    let lib_path = build_dir.join("build");
    println!("cargo:rustc-link-search=native={}", lib_path.display());

    println!("cargo:rerun-if-changed=include/graphar_rs.h");
    println!("cargo:rerun-if-changed=src/graphar_rs.cc");
    println!("cargo:rerun-if-changed=../cpp");

    // Include `cpp/src` and `thirdparty`
    vec![root.join("src/"), root.join("thirdparty/")]
}

fn main() {
    // Include `include/`
    let mut include_paths = vec![Path::new(env!("CARGO_MANIFEST_DIR")).join("include")];
    include_paths.extend(build_graphar());

    link_libraries();

    // Build files generated by `ffi.rs` and `graphar_rs.cc`
    build_ffi(
        "src/ffi.rs",
        "graphar_cxx",
        "src/graphar_rs.cc",
        &include_paths,
    );
}
